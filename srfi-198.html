<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI 198: Foreign Interface Error Handling</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org//srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1"></head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI logo" /></a>198: Foreign Interface Error Handling</h1>


<p>Authors</p>

John Cowan, Lassi Kortela, and Harold Ancell


<h2>Status</h2>


<h2>Abstract</h2>

When errors from Scheme interfaces to "foreign" systems such as the
P<small>OSIX</small> API, libraries, and databases are detected, this
SRFI provides the means to construct, return or signal, and extract
information from those errors in a reasonably uniform way.


<h2>Issues</h2>

<p>None at present.</p>


<h2>Rationale</h2>

<p>R6RS and R7RS-large have ambitions to become comprehensive
ecosystems useful for developing real world applications.  This
necessitates the development of many interfaces to "foreign" systems,
ranging from direct Foreign Function Interfaces (FFIs) to low level
assembler and C libraries, including APIs at that level such as
P<small>OSIX</small>, to protocols such as TCP/IP, all the way to
client-server systems such as databases running in their own
processes.</p>

<p>This SRFI provides a comprehensive framework for placing data about
errors from foreign systems into an object, starting with
<em>error-sets</em> to partition collections of related errors,
such as 'posix, 'postgresql, and 'libsodium, and to report them.</p>

<p>Sometimes it will make sense to simply return an error object, but
an often preferred method is to raise an exception, like
<a href="https://srfi.schemers.org/srfi-170/srfi-170.html">SRFI
170</a> in which procedures never return error codes, or use an
analogue of the P<small>OSIX</small> <code>errno</code> variable to
indicate system-call-level errors.</p>

<p>Thus procedures can return useful values, and the programmer can to
assume that if a foreign interface procedure returns, it succeeded.
This greatly simplifies the flow of the code from the programmer's
point of view.</p>


<h2>Specification</h2>

<!--
<dl>
<dt> <code>(set-errno! <i>errno</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>undefined</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</dt>
<dd>
<p>Sets the current value of <code>errno</code>, where the argument <code><i>errno</i></code> is an exact integer.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(errno) &rArr; 2
(set-errno! 0)
(errno) &rArr; 0
</pre></td></tr></table>
</dd>
</dl>
-->

<h3>Procedures</h3>

<h4>Error predicate</h4>

<dl>
<dt> <code>(foreign-error? <i>object</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</dt>
<dd>
<p>Returns #f unless <i>obj</i> is a SRFI 198 error.</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(foreign-error? "This is not an foreign-error-object") &rArr; #f
(foreign-error? (make-foreign-error <i>valid-alist</i>) &rArr; #t
</pre></td></tr></table>
</dd>
</dl>

<h4>Error field getters</h4>

<p>When an error set does not have a concept that corresponds to an error field, its value must be <code>#f</code>.  Implementations on small memory systems could reasonably omit message strings.

<dl>
<dt> <code>(foreign-error:error-set <i>foreign-error-object</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>symbol</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</dt>
<dd>
<p>Partitions the universe of foreign errors into distinct collections based on their source.
The set <code>'error</code> is reserved for generic errors, particularly sanity error checking before the foreign interface is invoked.
</p>

<table><tr><td>&nbsp;</td><td><pre class="example">(foreign-error:error-set <i>foreign-error-object</i>) &rArr; 'errno
</pre></td></tr></table>

<p>Typical error sets might include:</p>

<table>
<tr><th>'errno</th> <th><a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html">P<small>OSIX</small> errnos</a></th></tr>
<tr><th>'postgresql</th> <th><a href="https://www.postgresql.org/docs/current/errcodes-appendix.html">PostgreSQL errors</a></th></tr>
<tr><th>'libsodium</th> <th><a href="https://doc.libsodium.org/">The libsodium cryptograpghy library</a></th></tr>
</table>
</dd>
</dl>

<dt> <code>(foreign-error:code <i>foreign-error-object</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>alist</i> or <i>#f</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</dt>
<dd>
<p>Many <i>error-sets</i> are organized by simple "codes", such as numbers, short alphanumeric designations that should be represented as symbols, etc.  Each <i>error-set</i> should have conventions for this.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(foreign-error:code <i>P<small>OSIX</small>-foreign-error-object</i>) &rArr; ((number . 2) (symbol . 'errno/ENOENT)
(foreign-error:code <i>PostgresSQL-foreign-error-object</i>) &rArr; ((code . '28P01))
(foreign-error:code <i>libsodium-foreign-error-object</i>) &rArr; #f
</pre></td></tr></table>
</dd>
</dl>

<dt> <code>(foreign-error:scheme-procedure <i>foreign-error-object</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>symbol</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</dt>
<dd>
<p>The Scheme procedure in which the error object is created.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(foreign-error:scheme-procedure <i>P<small>OSIX</small>-foreign-error-object</i>) &rArr; 'open-file
(foreign-error:scheme-procedure <i>PostgreSQL-foreign-error-object</i>) &rArr; 'open-database-connection
(foreign-error:scheme-procedure <i>libsodium-foreign-error-object</i>) &rArr; 'generate-key
</pre></td></tr></table>
</dd>
</dl>

<dt> <code>(foreign-error:foreign-interface <i>foreign-error-object</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>symbol</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</dt>
<dd>
<p>The specific part of the foreign interface that raised an error.  For a library, the name of the library function that was called would be appropriate.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(foreign-error:foreign-interface <i>P<small>OSIX</small>-foreign-error-object</i>) &rArr; 'open
(foreign-error:interface <i>PostgresSQL-wire-foreign-error-object</i>) &rArr; ~~~FIX_ME
(foreign-error:foreign-interface <i>libsodium-foreign-error-object</i>) &rArr; 'sodium_init
</pre></td></tr></table>
</dd>
</dl>

<dt> <code>(foreign-error:locales <i>foreign-error-object</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>list of symbols</i> of <i>#f</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</dt>
<dd>
<p>The locales for which error messages are available.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(foreign-error:locales <i>foreign-error-object</i>) &rArr; ('en_US 'fi_FI)
</pre></td></tr></table>
</dd>
</dl>

<dt> <code>(foreign-error:message <i>foreign-error-object [locale]</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>string</i> or <i>#f</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</dt>
<dd>
<p>The default value for the locale is en_US.  In the construction of
the error message, implementers are encouraged to include relevant
information from the above fields, and the data field below.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(foreign-error:message <i>P<small>OSIX</small>-foreign-error-object</i>) &rArr; "open-file called open: errno/ENOENT: No such file or directory"
(foreign-error:message <i>foreign-error-object</i>) &rArr; "open-database-connection: ~~~FIX_ME-28P01: ~~~FIX_ME->Incorrect password<-"
(foreign-error:message <i>foreign-error-object</i>) &rArr; "generate-key: ecb-generate-key could not initialize sodium library"
~~~FIX_ME add Finnish error messages
</pre></td></tr></table>
</dd>
</dl>

<dt> <code>(foreign-error:data <i>foreign-error-object</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>alist</i> or <i>#f</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</dt>
<dd>
<p>
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(foreign-error:data <i>P<small>OSIX</small>-foreign-error-object</i>) &rArr; (('arguments . ("not-a-valid-filename" 0 428)) ('heritage . "SRFI 170"))
(foreign-error:data <i>PostgreSQL-foreign-error-object</i>) &rArr; (('arguments . ("localhost" 5432 "ecb" "ecb")))
(foreign-error:data <i>libsodium-foreign-error-object</i>) &rArr; #f
</pre></td></tr></table>
</dd>
<dd>
For login functions, you want to omit reporting and logging plaintext passwords.  For cryptographic libraries, the same for secret or private keys, and plaintext data.
</dd>
</dl>


<h4>Error constructors</h4>

<dl>
<dt> <code>(make-foreign-error <i>alist</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>foreign-error-object</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</dt>
<dt> <code>(raise-foreign-error <i>alist [continuable]</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>undefined</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</dt>
<dd>

<p>
These procedures are handed alists, the keys of the pairs being the
above getters after the colon such as 'message.
Only <code>'error-set</code> is required, omitted pairs will result in
the corresponing slots being set to <code>#f</code> except for locale,
which is generated based on the supplied messages.
The value for 'message can be either a string, in which case the
locale defaults to en_US, or an alist with keys for locales, and
suitable strings in each value.</p>

<p>
<code>raise-foreign-error</code> takes the <code>foreign-error-object</code>
returned by <code>make-foreign-error</code> and ideally raises an
exception in a manner suitable for the Scheme implementation it is
running on.  If the optional argument <code>continuable</code> is
not the defaul of <code>#f</code>, it will attempt to raise a
continuable exception.
</p>

<table><tr><td>&nbsp;</td><td><pre class="example">(foreign-error: <i>(make-foreign-error '((error-set . error)))</i>) &rArr; <i>error-set-object</i>
(make-foreign-error '((error-set . errno) (code . (number . 2) (symbol . errno/ENOENT)) (scheme-procedure . open-file) (foreign-interface . open) (message . "open-file called open: errno/ENOENT: No such file or directory") (('arguments . ("not-a-valid-filename" 0 428)) ('heritage . "SRFI 170"))</i>)) &rArr; <i>error-set-object</i> with <code>foreign-interface:locales</code> set to '(en_US)
(make-foreign-error '((error-set . errno) (code . (number . 2) (symbol . errno/ENOENT)) (scheme-procedure . open-file) (foreign-interface . open) (message . (en_us . "open-file called open: errno/ENOENT: No such file or directory") (fi_FI . "~~~FIX_ME insert Finnish version here")) (('arguments . ("not-a-valid-filename" 0 428)) ('heritage . "SRFI 170"))</i>)) &rArr; <i>error-set-object</i> with <code>foreign-interface:locales</code> set to '(en_US fi_FI)
(make-foreign-error '((error-set . 'libsodium) (scheme-procedure . generate-key) (foreign-interface . sodium-init) (message . "generate-key: ecb-generate-key could not initialize sodium library")))</i>) &rArr;  <i>error-set-object</i> with <code>foreign-interface:locales</code> set to '(en_US)
(raise-foreign-error '((error-set . error)))</i>) &rArr; <i>undefined</i>
(raise-foreign-error '((error-set . error))) #f</i>) &rArr; <i>undefined</i>, will attempt to raise a continuable exception.
</pre></td></tr></table>
</dd>
</dl>


<h2>Implementation</h2>

<p>
A sample work in progress implementation of this SRFI can be found in
the srfi directory of its repository.
</p>


<h2>Acknowledgments</h2>

<p>
Thanks to Olin Shivers and all the Scheme implementers who have
followed his work; this SRFI was inspired by scsh's
<code>errno-error</code> facility.  Thanks also to all the
participants in the SRFI 170 and SRFI 198 mailing lists.
</p>

<h2>Copyright</h2>
<p>Copyright &copy; John Cowan, Lassi Kortela, and Harold Ancell (2020).</p>

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:</p>

<p>
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial
  portions of the Software.</p>
<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.</p>

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
